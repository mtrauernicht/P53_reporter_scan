---
title: "Oligo Design Deep Scan"
author: "Max Trauernicht"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output: 
  html_document:
    theme: journal #cerulean
    highlight: monochrome
    toc: true
    toc_float: true
    code_folding: show
  editor_options:
    chunk_output_type: console
---

# knitr document van Steensel lab

# Oligo Design Deep Scan

# Introduction
In this script, oligos will be designed for a Trp53 and Gr activity reporter. TF binding sites with variable binding affinities will be placed upstream of a minimal TATA promoter (minP) and a barcode in the transcriptional unit.


## Description of Data
How to make a good rendering table: 
```{r table1, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
| column1	|	column2	|	column3	|	
|----|----|----|
|1	|	2	|	3	|	
|a	|	b	|	c	|	
"
cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
```

# Data processing
## Path, Libraries, Parameters and Useful Functions
```{r setup}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(ggplot2)
library(seqinr)
library(seqLogo)
library(universalmotif)
library(Biostrings)
library(SimRAD)
library(gtools)
library(DNABarcodes)
library(phylotools)
library(ape)
library(magrittr)
library(dplyr)
library(readr)
library(stringr)
library(tidyr)
library(heatmaply)
library(pheatmap)
library(tibble)
library(ggseqlogo)
library(RColorBrewer)
```

### Custom functions
Functions used thoughout this script.
```{r}
SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

# Function to substring the right part of the motif
substrRight <- function(x, n){
  substr(x, nchar(x)-n+1, nchar(x))
}


# Function to load PWM matrix
get_pwm_feature_matrix <- function(motif_meta_fn, fimo_fn, db = 2) {

  # validate args
  valid_dbs <- 1:2
  if(!db %in% valid_dbs)
    stop('Invalid db (database version). Please use db=1 (maintained for backward compatibility only) or db=2')

  # db=1 is maintained for backward compatibility only
  if(db == 1) {

    # read in motif metadata
    motif_meta    <- read.csv(motif_meta_fn)

    # check whether motif metadata contain essential annotations
    if(!all(c('PWM.ID', 'Cognate.TF') %in% colnames(motif_meta))) {
      message('The motif metadata file does not contain the essential columns PWM.ID and Cognate.TF')
    }

    motif_minimal <- motif_meta[, c('PWM.ID', 'Cognate.TF')]

    # load fimo output --> extract motif id, sequence id and p-value
    df <- read.table(fimo_fn)
    df <- df[, c(1, 2, 7)]

    colnames(df) <- c('PWM.ID', 'seqid', 'pval')

    # add TF id
    df <- merge(df, motif_minimal, by = 'PWM.ID')

    # group motif hits by sequence id
    l <- split(df, df[['seqid']])

    # multiple PWM and multiple hits possible. Reduce hits to one per TF, keeping best p-val only
    l <- lapply(l, function(x) {
      x_by_tf <- split(x, x[['Cognate.TF']], drop = TRUE)
      x_by_tf <- lapply(x_by_tf, function(y) y[which.min(y$pval), ])
      do.call('rbind', x_by_tf)
    })

    # initialize feature matrix
    n_tf          <- motif_minimal[['Cognate.TF']] %>%
      unique %>%
      length
    n_seq         <- length(l)
    pwm           <- matrix(1, nrow = n_seq, ncol = n_tf)
    colnames(pwm) <- (motif_minimal[['Cognate.TF']] %>% unique)

    # replace :: from names of composite motifs
    colnames(pwm) <- str_replace_all(colnames(pwm), '::', '_')

    # fill in feature matrix
    for(i in 1 : n_seq) {
      pwm[i, l[[i]][['Cognate.TF']]] <- l[[i]]$pval
    }

    # -log10 transform
    pwm           <- -1 * log10(pwm)

    # coerce to tib and return
    tib_fimo <- as_data_frame(pwm) %>%
      mutate(id = names(l))
      dplyr::select(id, everything())

  }

  # db = 2 (default)
  else {

    # load metadata
    tib_meta    <- read_csv(motif_meta_fn) %>%
      # extract tf symbol from motif id (Cognate_TF unsafe, it can be empty) and replace :: occurrences
      mutate(tf_symbol = str_remove(ID, '_[0-9]*'),
             tf_symbol = str_replace(tf_symbol, '::', '_')) %>%
      select(motif_id = `PWM ID`, tf_symbol)

    # load fimo results
    tib_fimo <- read_tsv(fimo_fn) %>%
      # extract motif id, sequence id and p-value
      select(motif_id, sequence_name, pval = `p-value`)

    # add tf symbol to fimo results
    tib_fimo <- tib_fimo %>%
      left_join(tib_meta, by = 'motif_id') %>%
      # remove hits with missing motif id (composite pwms)
      filter(!is.na(tf_symbol))

    # select best hit for each motif and sequence
    tib_fimo <- tib_fimo %>%
      group_by(sequence_name, tf_symbol) %>%
      dplyr::slice(which.min(pval)) %>%
      ungroup()

    # spread into feature matrix
    tib_fimo <- tib_fimo %>%
      mutate(pval = -1 * log10(pval)) %>%
      select(-motif_id) %>%
      spread(key = tf_symbol, value = pval, fill = 0, drop = TRUE) %>%
      # perform cosmetics on the id
      mutate(id = sequence_name) %>%
      select(-c(sequence_name)) %>%
      select(id, everything())

  }

  return(tib_fimo)

}
```


## Data import
```{r}
# Import chosen TFs
motifs <- read.csv2("/DATA/usr/m.trauernicht/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/parameter_files/TF_motifs.csv", header = T)
```


## Create DNA barcodes
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# # Create barcodes with length = 12
# barc <- create.dnabarcodes(n = 12, dist = 3, filter.triplets = T,
#                            filter.gc = T, filter.self_complementary = T, cores = 24)

# write.csv2(barc, file = "/DATA/usr/m.trauernicht/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/parameter_files/barcodes.csv")
barc <- read.csv2("/DATA/usr/m.trauernicht/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/parameter_files/barcodes.csv", row.names = 1)
colnames(barc) <- "barcode"

# Filter out ATGs
barc <- barc[-grep("ATG",barc$barcode),]

# Filter out EcoRI & NheI sites
ecori_nhei <- c("GAATTC","GCTAGC")
barc <- barc[-grep(paste(ecori_nhei, collapse = "|"),barc)]
# 80.901 possible barcodes are made
```


# Oligo design

## Creating a surrogate DF - sequences will be added in later stages
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# Create all desired parameters here
## TF-motifs
tf.motifs <- data.frame(c("Trp53","Gr"))
names(tf.motifs) <- "tf"
## 8 barcodes
oligo.barcodes <- data.frame(1:3)
names(oligo.barcodes) <- "oligo.barcode"
## 10 distances - to test the nucleosome position theory
distances <- data.frame(1:10)
names(distances) <- "distance"
## 3 backgrounds
backgrounds <- data.frame(1:3)
names(backgrounds) <- "background"
## Combinations of high-med affinities
affinity_pos1 <- data.frame(c(0,1))
affinity_pos2 <- data.frame(c(0,1))
affinity_pos3 <- data.frame(c(0,1))
affinity_pos4 <- data.frame(c(0,1))
names(affinity_pos1) <- "affinity_pos1"
names(affinity_pos2) <- "affinity_pos2"
names(affinity_pos3) <- "affinity_pos3"
names(affinity_pos4) <- "affinity_pos4"


# Create whole df by merging all conditions
tf.df <- Reduce(function(x, y) merge(x, y, all=TRUE), list(tf.motifs, oligo.barcodes, distances, backgrounds,affinity_pos1, affinity_pos2, affinity_pos3,affinity_pos4))

## Combinations of med-low affinities
affinity_pos1 <- data.frame(c(1,2))
affinity_pos2 <- data.frame(c(1,2))
affinity_pos3 <- data.frame(c(1,2))
affinity_pos4 <- data.frame(c(1,2))
names(affinity_pos1) <- "affinity_pos1"
names(affinity_pos2) <- "affinity_pos2"
names(affinity_pos3) <- "affinity_pos3"
names(affinity_pos4) <- "affinity_pos4"

tf.df2 <- Reduce(function(x, y) merge(x, y, all=TRUE), list(tf.motifs, oligo.barcodes, backgrounds, distances, affinity_pos1, affinity_pos2, affinity_pos3, affinity_pos4))
## Combinations of med-low affinities
affinity_pos1 <- data.frame(c(2,3))
affinity_pos2 <- data.frame(c(2,3))
affinity_pos3 <- data.frame(c(2,3))
affinity_pos4 <- data.frame(c(2,3))
names(affinity_pos1) <- "affinity_pos1"
names(affinity_pos2) <- "affinity_pos2"
names(affinity_pos3) <- "affinity_pos3"
names(affinity_pos4) <- "affinity_pos4"

tf.df3 <- Reduce(function(x, y) merge(x, y, all=TRUE), list(tf.motifs, oligo.barcodes, backgrounds, distances, affinity_pos1, affinity_pos2, affinity_pos3, affinity_pos4))

## Combinations of med-low affinities
affinity_pos1 <- data.frame(c(3,4))
affinity_pos2 <- data.frame(c(3,4))
affinity_pos3 <- data.frame(c(3,4))
affinity_pos4 <- data.frame(c(3,4))
names(affinity_pos1) <- "affinity_pos1"
names(affinity_pos2) <- "affinity_pos2"
names(affinity_pos3) <- "affinity_pos3"
names(affinity_pos4) <- "affinity_pos4"

tf.df4 <- Reduce(function(x, y) merge(x, y, all=TRUE), list(tf.motifs, oligo.barcodes, backgrounds, distances, affinity_pos1, affinity_pos2, affinity_pos3, affinity_pos4))

tf.df <- unique(rbind(tf.df,tf.df2,tf.df3,tf.df4))

# Adding the DNA sequence from 5' to 3'

## Constant 5' primer sequence
tf.df$primer1_seq <- "CGGAGCGAACCGAGTTAG"


### Motif 1-4
for (i in unique(tf.df$affinity_pos1)) {
  for (j in unique(tf.df$tf)) {
  tf.df$motif1[tf.df$affinity_pos1 == i & tf.df$tf == j] <- 
    motifs$Motif[motifs$TF == j & motifs$Affinity == i]
  tf.df$motif2[tf.df$affinity_pos2 == i & tf.df$tf == j] <- 
    motifs$Motif[motifs$TF == j & motifs$Affinity == i]
  tf.df$motif3[tf.df$affinity_pos3 == i & tf.df$tf == j] <- 
    motifs$Motif[motifs$TF == j & motifs$Affinity == i]
  tf.df$motif4[tf.df$affinity_pos4 == i & tf.df$tf == j] <- 
    motifs$Motif[motifs$TF == j & motifs$Affinity == i]
  }
}

## Spacer sequence between TF motifs 
tf.df$space1 <- ""
tf.df$space2 <- ""
tf.df$space3 <- ""
tf.df$distance.seq <- ""

## Minimal promoter (minP)
tf.df$promoter <- "minP"
tf.df$promoter_sequence <- "TAGAGGGTATATAATGGAAGCTCGACTTCCAG"

## S1 Illumina adapter
tf.df$s1_primer <- "CACGACGCTCTTCCGATCT"

## Barcode
tf.df$barcode <- ""

## 3' Primer sequence
tf.df$primer2_seq <- "TACATCGTCGCATCCAAG"
```






## Add positive & negative controls
```{r}
# Random inactive promoters
promoter_inactive <- "GGTTAGCGATCCAATTCAGCTAGATTTTAAGC"

# Just select the first random sequence promoter for a single condition 
# Select 10bp spacer, 21bp distance, minP, background 1 - keep all replicates & all TFs
# Bind to tf.df
rd.promoter <- tf.df
rd.promoter <- rd.promoter[rd.promoter$affinity_pos1 == "0" & rd.promoter$affinity_pos2 == "0" &
                           rd.promoter$affinity_pos3 == "0" & rd.promoter$affinity_pos4 == "0",]
rd.promoter$promoter <- "Random"
rd.promoter$promoter_sequence <- promoter_inactive
tf.df <- rbind(tf.df, rd.promoter)

# Add some control motifs
control.df <- subset(tf.df, select = c(-tf,-motif1,-motif2,-motif3,-motif4))
control.df <- unique(control.df[control.df$affinity_pos1 == "0" & control.df$affinity_pos2 == "0" &
                           control.df$affinity_pos3 == "0" & control.df$affinity_pos4 == "0",])

control.motifs <- read.csv2("/DATA/usr/m.trauernicht/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/parameter_files/TF_motifs_ctrl.csv", header = T)
control.motifs <- merge(control.motifs, control.df)

tf.df <- rbind(tf.df, control.motifs)
```






## Generate and test spacers between TF motifs
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# Subselect one spacing and neighboring TF motifs, make rows for random spacings that will be created
motif_10bp <- tf.df %>% select(tf, motif1, motif2, affinity_pos1, affinity_pos2) %>% unique()
motif_10bp <- motif_10bp[motif_10bp$tf != "Trp53",]
motif_10bp$spacing <- ""
iteration <- 1:2000
motif_10bp <- merge(motif_10bp, iteration, all=T)

# Generate 2000 random spacings between TF motifs
# GC content ~50%
set.seed(374312)
for (i in 1:2000) {
  motif_10bp$spacing[motif_10bp$y ==i] <- sim.DNAseq(10, GCfreq = 0.5)
}

motif_10bp_space <- motif_10bp
motif_10bp_space$seq.name <- paste(motif_10bp_space$tf, motif_10bp_space$affinity_pos1, motif_10bp_space$affinity_pos2,  motif_10bp_space$y, sep = "_")


# Assemble sequence to test: 4 rim bases of the TF motifs and the spacer sequence
motif_10bp_space$seq.text <- paste(substrRight(motif_10bp_space$motif1, 4), 
                       motif_10bp_space$spacing, 
                       substr(motif_10bp_space$motif2, 1, 4), sep = "")

# Write fasta file to run on FIMO script
motif_10bp_space_export <- motif_10bp_space
motif_10bp_space_export <- motif_10bp_space_export %>% select(seq.name, seq.text) %>% unique()
dat2fasta(motif_10bp_space_export, outfile = "/DATA/usr/m.trauernicht/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/fimo/spacings.fasta")     
```

## Run FIMO script again 
```{bash run fimo spacings, eval = FALSE}
# motfn=/home/f.comoglio/mydata/Annotations/TFDB/Curated_Natoli/update_2017/20170320_pwms_selected.meme
# odir=/home/m.trauernicht/mydata/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/output/spacings_Gr
# query=/home/m.trauernicht/mydata/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/fimo/spacings.fasta

# nice -n 19 fimo --no-qvalue --thresh 1e-4 --verbosity 1 --o $odir $motfn $query 
```


## load fimo results
We built a TF motif matrix using -log10 transformed FIMO scores. We used this feature encoding throughout the rest of this analysis, unless otherwise stated. 

```{r build tf motif matrices db2: tf_check, out.width= "100%", fig.align= "center", echo=FALSE}
# load motif Metadata --> PWM feature matrix
tib_pwm_10bp_spacer_Gr  <- get_pwm_feature_matrix(motif_meta_fn = '/home/f.comoglio/mydata/Annotations/TFDB/Curated_Natoli/update_2017/fc181127_curated_metadata_no_composite_filt.csv', 
                                        fimo_fn       = '/home/m.trauernicht/mydata/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/output/spacings_Gr/fimo.tsv',
                                        db            = 2)
```



## visualize fimo results
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
## We make a selection of 9 10bp spacer
# convert to binary
tib_pwm_10bp_spacer_Gr_binary <- tib_pwm_10bp_spacer_Gr %>% mutate_if(is.numeric, function(x) ifelse((x==0 | is.na(x)),0,1)) 
tib_pwm_10bp_spacer_Gr_binary_top <- tib_pwm_10bp_spacer_Gr_binary

# compute rowsums to get cumulative binding
tib_pwm_10bp_spacer_Gr_binary_top$binding <- rowSums(tib_pwm_10bp_spacer_Gr_binary_top[,2:ncol(tib_pwm_10bp_spacer_Gr_binary_top)])

# select only cumulative binding and id
tib_pwm_10bp_spacer_Gr_binary_top <- tib_pwm_10bp_spacer_Gr_binary_top %>%
  select(id,binding)

# make third column wiht only the space_id - then sum up the binding scores per space_id
tib_pwm_10bp_spacer_Gr_binary_top$space <- gsub(".*_(.*)", "\\1", tib_pwm_10bp_spacer_Gr_binary_top$id)
tib_pwm_10bp_spacer_Gr_binary_top <- tib_pwm_10bp_spacer_Gr_binary_top %>%
  select(-id)
tib_pwm_10bp_spacer_Gr_binary_top$cum_binding <- ave(tib_pwm_10bp_spacer_Gr_binary_top$binding, tib_pwm_10bp_spacer_Gr_binary_top$space,
                                             FUN = sum)
tib_pwm_10bp_spacer_Gr_binary_top <- tib_pwm_10bp_spacer_Gr_binary_top %>%
  select(-binding)
tib_pwm_10bp_spacer_Gr_binary_top <- unique(tib_pwm_10bp_spacer_Gr_binary_top)

# Identify spacers that were exlcuded from fimo script (due to 0 hits)
space_id <- unique(tib_pwm_10bp_spacer_Gr_binary_top$space)
iteration <- 1:2000
space_nohit <- iteration[! iteration %in% space_id]
# We have 3 hits here already

# Remove EcoRI/NheI sites
remove_10bp <- motif_10bp_space[grep(paste(ecori_nhei, collapse = "|"), motif_10bp_space$seq.text),]
remove_10bp <- unique(remove_10bp$y)
space_nohit <- space_nohit[!space_nohit %in% remove_10bp]
# 18 hits

# Select sequences from original file
spacers_10bp_selected <- unique(motif_10bp[motif_10bp$y %in% space_nohit,6])
```







## Generate and test spacers between TF motifs - 7 bp to be in phase for Trp53 (10 bp was for Gr)
## Test top 10 bp spacers - and test if they're still good for 7 bp
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# Subselect one spacing and neighboring TF motifs, make rows for random spacings that will be created
spacers_7bp <- tf.df %>% select(tf, motif1, motif2, affinity_pos1, affinity_pos2) %>% unique()
spacers_7bp <- spacers_7bp[spacers_7bp$tf == "Trp53",]
spacers_10bp <- as.data.frame(substr(spacers_10bp_selected, 1, 7))
spacers_10bp$iteration <- 1:18
names(spacers_10bp) <- c("spacing", "iteration")
spacers_7bp <- merge(spacers_7bp, spacers_10bp)

spacers_7bp$seq.name <- paste(spacers_7bp$tf, spacers_7bp$affinity_pos1, spacers_7bp$affinity_pos2,  spacers_7bp$iteration, sep = "_")

spacers_7bp_space <- spacers_7bp

# Assemble sequence to test: 4 rim bases of the TF motifs and the spacer sequence
spacers_7bp_space$seq.text <- paste(substrRight(spacers_7bp_space$motif1, 4), 
                       spacers_7bp_space$spacing, 
                       substr(spacers_7bp_space$motif2, 1, 4), sep = "")



# Write fasta file to run on FIMO script
spacers_7bp_space_export <- spacers_7bp_space
spacers_7bp_space_export <- spacers_7bp_space_export %>% select(seq.name, seq.text) %>% unique()
# dat2fasta(spacers_7bp_space_export, outfile = "/DATA/usr/m.trauernicht/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/fimo/spacings_trp53.fasta")     
```

## Run FIMO script again 
```{bash run fimo spacings, eval = FALSE}
# motfn=/home/f.comoglio/mydata/Annotations/TFDB/Curated_Natoli/update_2017/20170320_pwms_selected.meme
# odir=/home/m.trauernicht/mydata/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/output/spacings_Trp53
# query=/home/m.trauernicht/mydata/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/fimo/spacings_trp53.fasta

# nice -n 19 fimo --no-qvalue --thresh 1e-4 --verbosity 1 --o $odir $motfn $query 
```










## load fimo results
We built a TF motif matrix using -log10 transformed FIMO scores. We used this feature encoding throughout the rest of this analysis, unless otherwise stated. 

```{r build tf motif matrices db2: tf_check, out.width= "100%", fig.align= "center", echo=FALSE}
# load motif Metadata --> PWM feature matrix
tib_pwm_10bp_spacer_Trp53  <- get_pwm_feature_matrix(motif_meta_fn = '/home/f.comoglio/mydata/Annotations/TFDB/Curated_Natoli/update_2017/fc181127_curated_metadata_no_composite_filt.csv', 
                                        fimo_fn       = '/home/m.trauernicht/mydata/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/output/spacings_Trp53/fimo.tsv',
                                        db            = 2)
```



## visualize fimo results
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
## We make a selection of 9 10bp spacer
# convert to binary
tib_pwm_10bp_spacer_Trp53_binary <- tib_pwm_10bp_spacer_Trp53 %>% mutate_if(is.numeric, function(x) ifelse((x==0 | is.na(x)),0,1)) 
tib_pwm_10bp_spacer_Trp53_binary_top <- tib_pwm_10bp_spacer_Trp53_binary

# compute rowsums to get cumulative binding
tib_pwm_10bp_spacer_Trp53_binary_top$binding <- rowSums(tib_pwm_10bp_spacer_Trp53_binary_top[,2:ncol(tib_pwm_10bp_spacer_Trp53_binary_top)])

# select only cumulative binding and id
tib_pwm_10bp_spacer_Trp53_binary_top <- tib_pwm_10bp_spacer_Trp53_binary_top %>%
  select(id,binding)

# make third column wiht only the space_id - then sum up the binding scores per space_id
tib_pwm_10bp_spacer_Trp53_binary_top$space <- gsub(".*_(.*)", "\\1", tib_pwm_10bp_spacer_Trp53_binary_top$id)
tib_pwm_10bp_spacer_Trp53_binary_top <- tib_pwm_10bp_spacer_Trp53_binary_top %>%
  select(-id)
tib_pwm_10bp_spacer_Trp53_binary_top$cum_binding <- ave(tib_pwm_10bp_spacer_Trp53_binary_top$binding, tib_pwm_10bp_spacer_Trp53_binary_top$space,
                                             FUN = sum)
tib_pwm_10bp_spacer_Trp53_binary_top <- tib_pwm_10bp_spacer_Trp53_binary_top %>%
  select(-binding)
tib_pwm_10bp_spacer_Trp53_binary_top <- unique(tib_pwm_10bp_spacer_Trp53_binary_top)

# Identify spacers that were exlcuded from fimo script (due to 0 hits)
space_id <- unique(tib_pwm_10bp_spacer_Trp53_binary_top$space)
iteration <- 1:18
space_nohit <- iteration[! iteration %in% space_id]

# Remove EcoRI/NheI sites
remove_10bp <- motif_10bp_space[grep(paste(ecori_nhei, collapse = "|"), motif_10bp_space$seq.text),]
remove_10bp <- unique(remove_10bp$y)
space_nohit <- space_nohit[!space_nohit %in% remove_10bp]
# 14 from the 18 spacers are no hits

# Select sequences from original file
spacers_selected <- unique(spacers_7bp[spacers_7bp$iteration %in% space_nohit,6])
spacers_selected <- spacers_10bp_selected[grep(paste(spacers_selected,collapse="|"), spacers_10bp_selected)]
```









## Also generate new spacings between minP and first TF motif
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# Subselect one spacing and neighboring TF motifs, make rows for random spacings that will be created
motif_dist <- tf.df %>% select(tf, motif4, affinity_pos4, promoter_sequence) %>% unique()
motif_dist$dist <- ""
iteration <- 1:2000
motif_dist <- merge(motif_dist, iteration, all=T)

# Generate 2000 random spacings between TF motifs
# GC content ~50%
set.seed(328483)
for (i in 1:2000) {
  motif_dist$dist[motif_dist$y ==i] <- sim.DNAseq(21, GCfreq = 0.5)
}

motif_dist_space <- motif_dist
motif_dist_space$seq.name <- paste(motif_dist_space$tf, motif_dist_space$affinity_pos4,
                                   motif_dist_space$y, sep = "_")


# Assemble sequence to test: 4 rim bases of the TF motif and the minP + and the spacer sequence
motif_dist_space$seq.text <- paste(substrRight(motif_dist_space$motif4, 4), 
                       motif_dist_space$dist, 
                       substr(motif_dist_space$promoter_sequence, 1, 4), sep = "")

# Write fasta file to run on FIMO script
motif_dist_space_export <- motif_dist_space
motif_dist_space_export <- motif_dist_space_export %>% select(seq.name, seq.text) %>% unique()
dat2fasta(motif_dist_space_export, outfile = "/DATA/usr/m.trauernicht/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/fimo/distance2.fasta")     
```


## Run FIMO script again 
```{bash run fimo distance, eval = FALSE}
# motfn=/home/f.comoglio/mydata/Annotations/TFDB/Curated_Natoli/update_2017/20170320_pwms_selected.meme
# odir=/home/m.trauernicht/mydata/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/output/distance2
# query=/home/m.trauernicht/mydata/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/fimo/distance2.fasta

# nice -n 19 fimo --no-qvalue --thresh 1e-4 --verbosity 1 --o $odir $motfn $query 
```


## load fimo results
We built a TF motif matrix using -log10 transformed FIMO scores. We used this feature encoding throughout the rest of this analysis, unless otherwise stated. 

```{r build tf motif matrices db2: tf_check, out.width= "100%", fig.align= "center", echo=FALSE}
# load motif Metadata --> PWM feature matrix
tib_pwm_distance  <- get_pwm_feature_matrix(motif_meta_fn = '/home/f.comoglio/mydata/Annotations/TFDB/Curated_Natoli/update_2017/fc181127_curated_metadata_no_composite_filt.csv', 
                                        fimo_fn       = '/home/m.trauernicht/mydata/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/output/distance2/fimo.tsv',
                                        db            = 2)
```



## visualize fimo results
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
## We make a selection of 9 10bp spacer
# convert to binary
tib_pwm_distance_binary <- tib_pwm_distance %>% mutate_if(is.numeric, function(x) ifelse((x==0 | is.na(x)),0,1)) 
tib_pwm_distance_binary_top <- tib_pwm_distance_binary

# compute rowsums to get cumulative binding
tib_pwm_distance_binary_top$binding <- rowSums(tib_pwm_distance_binary_top[,2:ncol(tib_pwm_distance_binary_top)])

# select only cumulative binding and id
tib_pwm_distance_binary_top <- tib_pwm_distance_binary_top %>%
  select(id,binding)

# make third column wiht only the space_id - then sum up the binding scores per space_id
tib_pwm_distance_binary_top$space <- gsub(".*_(.*)", "\\1", tib_pwm_distance_binary_top$id)
tib_pwm_distance_binary_top <- tib_pwm_distance_binary_top %>%
  select(-id)
tib_pwm_distance_binary_top$cum_binding <- ave(tib_pwm_distance_binary_top$binding, tib_pwm_distance_binary_top$space,
                                             FUN = sum)
tib_pwm_distance_binary_top <- tib_pwm_distance_binary_top %>%
  select(-binding)
tib_pwm_distance_binary_top <- unique(tib_pwm_distance_binary_top)

# Identify spacers that were exlcuded from fimo script (due to 0 hits)
space_id <- unique(tib_pwm_distance_binary_top$space)
iteration <- 1:2000
space_nohit <- iteration[! iteration %in% space_id]
# We have 699 hits here already

# Remove EcoRI/NheI sites
remove_dist <- motif_dist_space[grep(paste(ecori_nhei, collapse = "|"), motif_dist_space$seq.text),]
remove_dist <- unique(remove_dist$y)
space_nohit <- space_nohit[!space_nohit %in% remove_dist]
# 28 hits
```


```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# Based on the heatmap above we choose the top 3 hits: 
distance_selected <- space_nohit[1:3]

# Select sequences from original file
distance_selected <- unique(motif_dist[motif_dist$y %in% distance_selected,5])
```




## Add new spacings to tf.df
```{r}
spacers_10bp_selected <- spacers_10bp_selected[-1]

# Add new spacings
for (i in 1:3) {
  tf.df$space1[tf.df$background == i & tf.df$tf != "Trp53"] <- spacers_10bp_selected[i]
  tf.df$space2[tf.df$background == i & tf.df$tf != "Trp53"] <- spacers_10bp_selected[i]
  tf.df$space3[tf.df$background == i & tf.df$tf != "Trp53"] <- spacers_10bp_selected[i]
}

for (i in 1:3) {
  tf.df$space1[tf.df$background == i & tf.df$tf == "Trp53"] <- substr(spacers_10bp_selected[i], 1, 7)
  tf.df$space2[tf.df$background == i & tf.df$tf == "Trp53"] <- substr(spacers_10bp_selected[i], 1, 7)
  tf.df$space3[tf.df$background == i & tf.df$tf == "Trp53"] <- substr(spacers_10bp_selected[i], 1, 7)
}

for (i in 1:3) {
  tf.df$distance.seq[tf.df$background == i] <- distance_selected[i]
}
```





## Check by FIMO if all spacings are inactive
```{r}
# Combine sequence and screen for binding
tf.df$seq.name <- paste(tf.df$tf, tf.df$oligo.barcode, tf.df$background, tf.df$affinity_pos1,
                           tf.df$affinity_pos2, tf.df$affinity_pos3, tf.df$affinity_pos4, 
                        tf.df$promoter, sep = "_")
tf.df$seq.text <- paste(tf.df$primer1_seq, tf.df$motif1, tf.df$space1, tf.df$motif2,
                      tf.df$space2, tf.df$motif3, tf.df$space3, tf.df$motif4, tf.df$distance.seq, 
                      sep = "")

tf.df.export <- subset(tf.df, select = c(seq.name, seq.text))

# dat2fasta(tf.df.export, outfile = "/DATA/usr/m.trauernicht/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/fimo/sequence_check_new_spacing.fasta")
```

## Run FIMO script again 
```{bash run fimo db2_9, eval = FALSE}
# motfn=/home/f.comoglio/mydata/Annotations/TFDB/Curated_Natoli/update_2017/20170320_pwms_selected.meme
# odir=/home/m.trauernicht/mydata/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/output/complete_seq
# query=/home/m.trauernicht/mydata/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/fimo/sequence_check_new_spacing.fasta

# nice -n 19 fimo --no-qvalue --thresh 1e-4 --verbosity 1 --o $odir $motfn $query 
```


## load fimo results
We built a TF motif matrix using -log10 transformed FIMO scores. We used this feature encoding throughout the rest of this analysis, unless otherwise stated. 

```{r build tf motif matrices db2: tf_check, out.width= "100%", fig.align= "center", echo=FALSE}
# load motif Metadata --> PWM feature matrix
tib_pwm_tf_check  <- get_pwm_feature_matrix(motif_meta_fn = '/home/f.comoglio/mydata/Annotations/TFDB/Curated_Natoli/update_2017/fc181127_curated_metadata_no_composite_filt.csv', 
                                        fimo_fn       = '/home/m.trauernicht/mydata/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/trp53_model/output/complete_seq/fimo.tsv',
                                        db            = 2)
```


```{r, fig.height=4, fig.width=4, out.width= "100%", fig.align= "center", echo=FALSE, eval=FALSE}
# Generate heatmaps in a loop for each TF and each affinity group
# Select only hits
tib_pwm_tf_check$TF <- gsub("[.*.|_].*","\\1",tib_pwm_tf_check$id)
tib_pwm_tf_check <- tib_pwm_tf_check[grepl('minP',tib_pwm_tf_check$id),]



# Add affinity label
## Add affinity information
tf.labels <- subset(tf.df, select = c(seq.name, affinity_pos1, affinity_pos2, affinity_pos3,
                                         affinity_pos4))
names(tf.labels) <- c("id", "affinity_1", "affinity_2", "affinity_3", "affinity_4")
tib_pwm_tf_check <- merge(tib_pwm_tf_check, tf.labels)

## Compute affinity sum
tib_pwm_tf_check$affinity <- tib_pwm_tf_check$affinity_1 + tib_pwm_tf_check$affinity_2 + tib_pwm_tf_check$affinity_3 + tib_pwm_tf_check$affinity_4

## Add label to each affinity sum
labels <- data.frame(c("4xhigh", "3xhigh - 1xmed", "2xhigh - 2xmed", "1xhigh - 3xmed", "4xmed",
            "3xmed - 1xlow", "2xmed - 2xlow", "1xmed - 3xlow", "4xlow", "3xlow - 1xvery_low", 
            "2xlow - 2xvery_low", "1xlow - 3xvery_low", "4xvery_low", "3xvery_low - 1xnull",
            "2xvery_low - 2xnull", "1xvery_low - 3xnull", "4xnull"), c(0:16))
names(labels) <- c("label", "affinity")

for (i in 0:16) {
  tib_pwm_tf_check$label[tib_pwm_tf_check$affinity == i] <- labels$label[labels$affinity == i]
}

tib_pwm_tf_check$label <- paste(tib_pwm_tf_check$TF, tib_pwm_tf_check$label, sep = "_")

## Rename rownames for heatmap visualization
tib_pwm_tf_check_2 <- unique(tib_pwm_tf_check) %>% 
  remove_rownames %>% column_to_rownames(var="id")

myBreaks1 <- seq(0,10,0.1)

# Create heatmaps for each TF
for (i in unique(tib_pwm_tf_check_2$label)) {
  data <- tib_pwm_tf_check_2[tib_pwm_tf_check_2$label == i,]
  data <- data %>% select (-label, -TF, -affinity, -affinity_1, -affinity_2, -affinity_3, -affinity_4)
  data <- data[,colSums(data != 0) > 0]
p <- pheatmap(as.matrix(data), 
              main = paste(i),
              border_color = "#000000",
              breaks = myBreaks1)
print(p)
}
```




```{r, fig.height=4, fig.width=4, out.width= "100%", fig.align= "center", echo=FALSE, eval=FALSE}
## Correlation model affinity score vs. predicted FIMO affinity
cor_sequences <- tib_pwm_tf_check %>% select(TF, affinity, NR3C1, TP53)
cor_sequences <- cor_sequences[cor_sequences$affinity == c(0,4,8,12,16),]
cor_sequences$affinity[cor_sequences$affinity == 0] <- "high"
cor_sequences$affinity[cor_sequences$affinity == 4] <- "med"
cor_sequences$affinity[cor_sequences$affinity == 8] <- "low"
cor_sequences$affinity[cor_sequences$affinity == 12] <- "very low"
cor_sequences$affinity[cor_sequences$affinity == 16] <- "null"
cor_sequences <- unique(cor_sequences)

# Order x-axis
cor_sequences$affinity <- factor(cor_sequences$affinity ,levels = c("high", "med", "low", "very low", "null"))


### Gr
ggplot(cor_sequences[cor_sequences$TF == "Gr",], aes(x = affinity, y = NR3C1)) +
  geom_bar(stat="identity") +
  xlab("Selex predicted binding site in reporter") + ylab("FIMO predicted affinity") +
  theme(text = element_text(size = 14)) +
  labs(title= paste("SELEX vs FIMO affinity, Gr")) +
  theme_classic()
 
### Trp53
ggplot(cor_sequences[cor_sequences$TF == "Trp53",], aes(x = affinity, y = TP53)) +
  geom_bar(stat="identity") +
  xlab("Selex predicted binding site in reporter") + ylab("FIMO predicted affinity") +
  theme(text = element_text(size = 14)) +
  labs(title= paste("SELEX vs FIMO affinity, Trp53")) +
  theme_classic()
```





## Add barcodes
```{r out.width= "100%", fig.align= "center", echo=FALSE}
barcodes <- read.csv2("/DATA/usr/m.trauernicht/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/output/mt20191213_barcodes_validated.csv")
barcodes <- list(barcodes)
set.seed(123)
barcodes <- sample(barcodes)
tf.df$barcode <- barcodes[1:nrow(tf.df)]

# Check if there are any duplicate barcodes
paste("duplicate barcodes: ", nrow(tf.df[duplicated(tf.df$barcode),]), sep ="")

# Save for later export
tf.df.long.export <- tf.df
```
















# Check-up & Visualizations
```{r out.width= "100%", fig.align= "center", echo=FALSE}
## Get main characteristics of designed oligo pool
# TF motif length distribution
tf.df2 <- unique(tf.df[,c(1,2)])
tf.df2 <- tf.df2[1:29,]


ggplot(tf.df2, aes(x = nchar(Motif))) +
   geom_histogram(aes(y=..count..), colour="black", fill="#E69F00", binwidth = 1)+ 
  xlab("Length TF motif") + ylab("Frequency") +
    labs(title = "Overview of TF motif lengths", 
         subtitle = paste("Total TFs =", length(unique(tf.df2$TF)), "|",  
         "max motif length =", max(nchar(tf.df2$Motif)), "|",
         "min motif length = ", min(nchar(tf.df2$Motif)), "|",
         "mean motif length = ", round(mean(nchar(tf.df2$Motif))))) +
  theme_classic() + scale_x_continuous(breaks=seq(0,18,1)) + 
  scale_y_continuous(breaks=seq(0,6,1)) 






# Length distribution
# Save intermediate df for later purpose
tf.array <- tf.df
tf.df$seq.text <- paste(tf.df$Primer1_seq, tf.df$motif1, tf.df$Space1, tf.df$motif2,
                    tf.df$Space2, tf.df$motif3, tf.df$Space3, tf.df$motif4, 
                    tf.df$Distance_seq, tf.df$Promoter_sequence, tf.df$S1_primer,
                    tf.df$barcode, tf.df$Primer2_seq, sep = "")
x <- tf.df[grep(paste(ecori_nhei, collapse = "|"),tf.df$seq.text),]
tf.df <- tf.df[,c(-8:-20)]
tf.df$nchar <- nchar(tf.df$seq.text)

ggplot(tf.df, aes(x = nchar)) +
   geom_histogram(aes(y=..count..), colour="black", fill="#E69F00", binwidth = 5)+ 
  xlab("Length Oligo (binwidth = 5)") + ylab("Frequency") +
    labs(title = "Overview of oligo lengths in pool", 
         subtitle = paste("Total oligos =", nrow(tf.df), "|",
                          "max oligo length =", max(nchar(tf.df$seq.text)), "|",
                          "min oligo length = ", min(nchar(tf.df$seq.text)), "|",
                          "mean oligo length = ", round(mean(nchar(tf.df$seq.text))))) +
  theme_classic()
```





## Exporting potential data. 
```{r}
```

# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

