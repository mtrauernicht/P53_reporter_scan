I am trying to make a model for the motif based MPRA designed by Max.
To test effects of interference Max designed a library for a single TF motif
either being present or absent at 4 different positions.

I will attempt to form some linear model to accurately model the TF activity
as well the interference between different motif positions.

```{r}
library(data.table)
library(ggplot2)
motif_dt = fread('/DATA/scratch/usr/c.leemans/projects/motif_SuRE/mt20210804_p53_sites_lm.csv')

aff_vec = c('affinity_pos1', 'affinity_pos2', 'affinity_pos3', 'affinity_pos4')
motif_dt[, aff_vec, with=F] = 4 - motif_dt[, aff_vec, with=F]

contribution1 = paste("x1 * affinity_pos1 *",
                      "(1 - interference_up * affinity_pos2)")
contribution2 = paste("x2 * affinity_pos2 *",
                      "(1 - interference_up * affinity_pos3) *",
                      "(1 - interference_down * affinity_pos1)")
contribution3 = paste("x3 * affinity_pos3 *",
                      "(1 - interference_up * affinity_pos4) *",
                      "(1 - interference_down * affinity_pos2) *",
                      "(1 - coop_down * affinity_pos1)")
contribution4 = paste("x4 * affinity_pos4 *",
                      "(1 - interference_down * affinity_pos3) *",
                      "(1 - coop_down * affinity_pos2)")

sum = paste(contribution1, contribution2, contribution3, contribution4,
            sep=' + ')

start = c(100, 400, 100, 400, 0.1, 0.1, 0.1)
names(start) = c('x1', 'x2', 'x3', 'x4', 'interference_up', 'interference_down',
                 'coop_down')

log_fit = nls(formula(paste('log10(barcode_activity) ~', sum)), motif_dt, start)


motif_dt[,log_predict:=predict(log_fit)]

ln_fit = nls(formula(paste('barcode_activity ~', sum)), motif_dt, start)


motif_dt[,ln_predict:=predict(ln_fit)]


unique_dt = unique(motif_dt[,c('motif_id', 'reporter_activity', 'log_predict',
                               'ln_predict')])

pdf('cl20210804_ODE_motif_interference.pdf', useDingbats=F)
ggplot(unique_dt, aes(x=log10(reporter_activity), y=log_predict)) +
    geom_point() +
    ggtitle('log10(reporter activity) prediction') +
    theme_bw()

ggplot(unique_dt, aes(x=log10(reporter_activity), y=log_predict, label=motif_id)) +
    geom_text() +
    ggtitle('log10(reporter activity) prediction') +
    theme_bw()

ggplot(unique_dt, aes(x=reporter_activity, y=ln_predict)) +
    geom_point() +
    ggtitle('linear reporter activity prediction') +
    theme_bw()
ggplot(unique_dt, aes(x=reporter_activity, y=ln_predict, label=motif_id)) +
    geom_text() +
    ggtitle('linear reporter activity prediction') +
    theme_bw()
dev.off()

summary(log_fit)

summary(ln_fit)

sse_log = sum(unique_dt[, ((10^log_predict)-reporter_activity)^2])
sse_ln = sum(unique_dt[, (ln_predict-reporter_activity)^2])

```
**conclusion:**
linear fit works better than fitting in log space. But there seems to be some
correction effects happening.
